Advanced REST API features
-----------------------------------
* Documentation
* Content Negotiation
* Internationalization
* Versioning
* HATEOAS
* Static Filtering
* Dynamic Filtering
* Monitoring
========================================================================================================================================
Documentation : Swagger and OpenAPI Specification 
------------------------------------------------------
* 2011 - Swagger specification and Swagger tools were introduced
* 2016 - Open API specification created based on swagger specification, 
			but Swagger tools (Swagger UI) continued to exist
* Swagger UI - to visualize and interact with your rest api 
* springdoc-openapi java library helps to automate the generation of API documentation for spring boot projects. 
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.0.0</version>
		</dependency>
* Add the dependency in pom.xml, and then restart the application
	# http://localhost:8080/swagger-ui/index.html#/
--------------------------------------------------------------------------------------------------------------------------------------------
Content Negotiation
-----------------------
* Same resource - same URI
	# Different representations are possible
		$ Different content type - XML or JSON or
		$ Different languages - English or Dutch
* Consumer should tell you what they want - content negotiation
	# Example: Accept header (MIME types - application/xml, application/json)
	# Example: Accept-Language header (en, nl, fr)
* To enable xml support, add the below dependency to pom.xml
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
		</dependency>
* Test the changes like below
	# Open Talend API tester, for any get action, add headers [Accept: application/xml]
	# Send the request
	# See the response body in xml format
--------------------------------------------------------------------------------------------------------------------------------------------
Internationalization - I18N
--------------------------------
* How do you customize to the users around the world? - I18N
* Typically, HTTP Request Header - Accept-Language is used
	# Accept-Language: Natural language and locale that consumer prefers
		# en - English (Good Morning)
		# nl - Dutch (Goedemorgen)
		# fr - French (Bonjour)
* Implementation:
	# Create files separately, named messages.properties, messages_{locale}.properties for how many ever locales required
	# Add a field messageSource in the resource class [org.springframework.context.MessageSource]
	# Call messageSource.getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) to get the value
		return messageSource.getMessage("good.morning.message", null, "Default Message", locale);
	# To get the locale for the current request, 
		Locale locale = LocaleContextHolder.getLocale();
* Test the changes like below
	# Open Talend API tester, for the action that uses i18N and messageSource, add headers [Accept-Language: en / nl / frs]
	# Send the request
	# See the response body in xml format
--------------------------------------------------------------------------------------------------------------------------------------------
Versioning REST APIs - URL versioning
----------------------------------------
* Variety of options
	# URL
	# Request parameter
	# Header
	# Media type

* URL: Different URLs for different versions (Twitter)
	# http://localhost:8080/v1/person
	# http://localhost:8080/v2/person
	
* Request Parameters: (Amazon)
	# http://localhost:8080/person?version=1
	# http://localhost:8080/person?version=2

* Custom headers versioning: (Microsoft)
	# SAME-URL headers=[X-API-VERSION=1]
	# SAME-URL headers=[X-API-VERSION=2] 

* Media type versioning [Content negotiation or Accept header] (Github)
	# SAME-URL produces=application/vnd.company.app-v1+json
	# SAME-URL produces=application/vnd.company.app-v2+json

Factors to consider:
---------------------
* URI pollution
	# URL and Request Parameters versioning, we will have many urls getting added.
* Misuse of headers
	# Headers and Media Type versioning misuse the headers, http headers are not meant for versioning
* Caching
	# Headers versioning and Media Type versioning use the same urls.
	# Caching based on the urls might be a problem, we will also need to consider headers for caching.
* Can we execute the request on the browser?
	# URL and Request Parameters versioning can be executed on the browser
	# Headers and Media Type versioning will need some command line utility or REST API client to differentiate based on the headers
* API Documentation
	# Tools for REST API documentation support for URL and Request Parameters versioning because they have different URL or different parameters
	# Tools for REST API documentation generally do not support for Headers versioning and Media Type versioning because they deal with headers

* Summary:
	# There is no perfect solution, many enterprises use different versioning
* Recommendations:
	# Think about versioning even before you need it
	# One enterprise - one versioning approach
--------------------------------------------------------------------------------------------------------------------------------------------
HATEOAS - Hypermedia as the Engine of Application State
---------------------------------------------------------
* Websites allows you to see DATA and perform ACTION (using links)
* How about enhancing your REST API to tell consumers how to perform subsequent actions?
	# HATEOAS
* Implementation options:
	# Custom format and implementation
		- Difficult to maintain
	# Use standard implementation
		- HAL (JSON HAL) (JSON Hypertext Application Language) 
		- simple format that gives a consistent and easy way to hyperlink between resources in your API
		- Spring HATEOAS - generate HAL responses with hyperlinks to resources
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-hateoas</artifactId>
		</dependency>
* Entity Model
* WebMvcLinkBuilder
--------------------------------------------------------------------------------------------------------------------------------------------
* Serialization : Convert object to stream
* Customizing the REST API response returned by Jackson framework
	# Customize the field names in response
		- @JsonProperty
	# Return only selected fields
		- Filtering (example, filter out passwords)

* Two types of filtering
	# Static filtering and Dynamic filtering

* Static filtering 
	# same filtering for a bean across different REST API.
	# like a password field is not part of any REST API
		- @JsonIgnore (at field level)
		- @JsonIgnoreProperties (at class level)

* Dynamic filtering
	# customizing filtering for a bean for specific REST API
	 

----------------------------------------------------------------------------
Dynamic filtering
---------------------

--------------------------------------------------------------------------------------------------------------------------------------------
References:
------------
* https://github.com/in28minutes/master-spring-and-spring-boot/tree/main/12-rest-api/01-step-by-step-changes/v2.md#step-21